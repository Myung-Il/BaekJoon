from sys import stdin
input = lambda:stdin.readline().rstrip()

N, M = map(int,input().split())
m = list(map(int,input().split()))
c = list(map(int,input().split()))

length = sum(c)+1
dp = [[0]*(N+1) for _ in range(length)]

# 메모리에 할당된 무게가 아닌 활성화 비용으로 문제를 해결함
for xi in range(1, N+1):
    p = c[xi-1] # 활성화 시 비용을 p에 저장

    # 이전의 정보를 가져옴
    for idx in range(length):dp[idx][xi] = dp[idx][xi-1]
    # 처음에는 저장된 정보가 없으니 전부 0이지만 아래 단계를 거치고 나면
    # 새로운 정보가 덮입혀져 다시 이전의 정보를 저장할 때 가져올게 생김

    # 비용이 사용되는 구간부터 메모리의 최대 사용량을 볼거임
    for yi in range(p, length):
        dp[yi][xi] = max(dp[yi][xi], dp[yi-p][xi-1]+m[xi-1])
        # 현재 정보(처음이라면 0, 아니라면 이전의 정보)와
        # 메모리에 넣을 수 있는 무게와 현재 메모리의 무게를 합친 값
        # max를 사용한 이유 : 문제에서 최소 비용으로 최대의 메모리 공간을 확보하라고 했기 때문
        # yi가 작을수록 비용이 적어지고 dp[yi][xi]의 값이 클수록 메모리공간을 확보했다는 이야기이다
                                                                # 물론 M만큼이 최대이다

for idx in range(length):
    if dp[idx][N]>=M:break
print(idx)


'''

5 100
20 20 20 20 20
0 0 0 0 0
= 0

7 120
20 91 92 93 94 95 100
1 2 2 2 2 2 2
= 3

24 1
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288 1048576 2097152 4194304 8388608
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
= 1

19 20169
240 2560 434 6 31 577 500 2715 2916 952 2490 258 1983 1576 3460 933 1660 2804 2584
82 77 81 0 36 6 53 78 49 82 82 33 66 8 60 0 98 91 93
= 484

5 60
30 10 20 35 40
0 1 0 0 0
= 0

7 120
20 91 92 93 94 95 100
1 2 2 2 2 2 2
= 3

'''